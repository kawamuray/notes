== Read/Write JS object fields from Rust

Context: Despite that https://docs.rs/wasm-bindgen/0.2.63/wasm_bindgen/struct.JsValue.html:[JsValue] provides various type conversion methods, the way accessing JS object like `{abc: "def"}` isn't mentioned anywhere.

Use https://rustwasm.github.io/wasm-bindgen/api/js_sys/Reflect/index.html:[Reflect] from `js_sys` crate.

[source,rust]
----
let value = Reflect::get(&obj, &JsValue::from_str("index"));
----

== `wasm_bindgen` doesn't support `Vec<_>`

Context: The sruct containing `Vec<_>` in its field doesn't allowed to be annotated with `#[wasm_bindgen]`.

As explained in this https://github.com/rustwasm/wasm-bindgen/issues/111:[issue] currently it is not supported.
There are many workarounds suggested but seems like the way using https://github.com/cloudflare/serde-wasm-bindgen:[serde-wasm-bindgen] is the most promising as of now. Or, just manually acccess individual fields with the above `Reflect`.


== Rust code towards WASI (syscall)

Having below Rust code compiled into `wasm32-wasi` target:

[source,rust]
----
OpenOptions::new()....open("/path/to/file");
----

trace call paths to understand how does it handled.

Read through wat output generated by `wasm2wat`.

[source,wasm]
----
  (func $std::fs::OpenOptions::open::h7da9bb0a725cc149 (type 10) (param i32 i32 i32 i32)
...
    call $std::fs::OpenOptions::_open::he342732572a6f81c

  (func $std::fs::OpenOptions::_open::he342732572a6f81c (type 10) (param i32 i32 i32 i32)
...
    call $std::sys::wasi::fs::open_parent::h15dfd170ea642f4b
# then
        call $std::sys::wasi::fs::open_at::h3f21205cd48e91f1
----

Impl of `$std::sys::wasi::fs::open_parent::h15dfd170ea642f4b` could be found rust https://github.com/rust-lang/rust/blob/1e9913807841153729f92e438e6189184cbf561f/library/std/src/sys/wasi/fs.rs#L624[stdlib source for wasi platform].

It calls `__wasilibc_find_relpath` which is in https://github.com/WebAssembly/wasi-libc/blob/84c0778bff35bca3b5fa7814a3e1f3fb36362af6/libc-bottom-half/sources/preopens.c#L118[wasi-libc].

It iterates over `preopens` that fd list that is registered at https://github.com/WebAssembly/wasi-libc/blob/84c0778bff35bca3b5fa7814a3e1f3fb36362af6/libc-bottom-half/sources/preopens.c#L77[internal_register_preopened_fd].

`internal_register_preopened_fd` is called by `__wasilibc_register_preopened_fd` and `__wasilibc_populate_preopens` where the former is likey an API to manually register preopened FD and the latter is automatically invoked routine to iterate over all FDs in process and register it by compiler extention `constructor` attribute. (does it actually called in wasm runtime? GCC document explains it to be called at the time shared library gets linked into).

Next, from `std::sys::wasi::fs::open_at::h3f21205cd48e91f1`.

It calls `wasi::fs::open_at` => `WasiFd::open` => `wasi::path_open`.
This `wasi` crate is https://github.com/bytecodealliance/wasi.
The `wasi` crate implements only interface generated from `witx` file and https://github.com/bytecodealliance/wasi/blob/main/src/lib_generated.rs#L1295[delegates] to `wasi_snapshot_preview1::path_open`.
`wasi_snapshot_preview1` functions are https://github.com/bytecodealliance/wasi/blob/main/src/lib_generated.rs#L1586[declared as extern wasm functions] and is dynamically linked at runtime.

The provider of `wasi_snapshot_preview1` module provider is at `wasmtime`.
`Wasi::add_to_linker(Linker)` https://github.com/bytecodealliance/wasmtime/blob/main/crates/wiggle/wasmtime/macro/src/lib.rs#L96[adds extern definitions] for `wasi_snapshot_preview1` functions.

The actual implementation of `path_open` happens as a `WasiSnapshotPreview1` trait impl for `WasiCtx` https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-common/src/snapshots/wasi_snapshot_preview1.rs#L13.

== Debug Rust WASI stack

To debug WASI stack on Rust we would have to probe into following two components:

* Rust stdlib (`library/std/src/sys/wasi/*`)
* https://github.com/WebAssembly/wasi-libc[`wasi-libc`] that Rust stdlib depends on

That involves manually building rust toolchain from source.

=== Build rust toolchain and link it to rustup

1. git clone https://github.com/rust-lang/rust.git
2. `./x.py build` as guided in README.
3. The final outputs are created under `./build/x86_64-apple-darwin/stage2`
4. `rustup toolchain link my-stable /path/to/rust/build/x86_64-apple-darwin/stage2`
5. `rustup override set my-stable` at project directory.

=== Add wasm32-wasi target to the built toolchain

The toolchain built by above flow doesn't supports `rustup target add ...` to add a target, hence we need to custom build process and let it to generate targets that we need.
To add `wasm32-wasi` target, first we need to build a `wasi-libc`.

1. git clone https://github.com/WebAssembly/wasi-libc.git
2. `make WASM_CC=/usr/local/Cellar/llvm/10.0.0_3/bin/clang WASM_AR=/usr/local/Cellar/llvm/10.0.0_3/bin/llvm-ar WASM_NM=/usr/local/Cellar/llvm/10.0.0_3/bin/llvm-nm -j8` (path might varies by llvm version)
3. The wasi sysroot created at `./sysroot`.

Next edit build configuration of rust to add build for extra targets.

1. `cp config.toml.example config.toml`
2. Edit config.toml as below:
[source,diff]
----
--- config.toml.example 2020-07-29 23:52:45.000000000 +0900
+++ config.toml 2020-08-03 23:40:49.000000000 +0900
@@ -129,7 +129,7 @@
 # In addition to all host triples, other triples to produce the standard library
 # for. Each host triple will be used to produce a copy of the standard library
 # for each target triple.
-#target = ["x86_64-unknown-linux-gnu"] # defaults to just the build triple
+target = ["wasm32-wasi", "wasm32-unknown-unknown"]
 
 # Use this directory to store build artifacts.
 # You can use "$ROOT" to indicate the root of the git repository.
@@ -400,7 +400,7 @@
 
 # Indicates whether LLD will be compiled and made available in the sysroot for
 # rustc to execute.
-#lld = false
+lld = true
 
 # Indicates whether LLD will be used to link Rust crates during bootstrap on
 # supported platforms. The LLD from the bootstrap distribution will be used
@@ -508,8 +508,9 @@
 # linked binaries
 #musl-root = "..."
 
+[target.wasm32-wasi]
 # The root location of the `wasm32-wasi` sysroot.
-#wasi-root = "..."
+wasi-root = "/path/to/wasi-libc/sysroot"
 
 # Used in testing for configuring where the QEMU images are located, you
 # probably don't want to use this.
----
3. Build rust again `./x.py build`
4. Extra targets are built at `build/x86_64-apple-darwin/stage2/lib/rustlib/wasm32-wasi`

=== Add arbitrary debug code to rust or wasi-libc

Then build entire toolchain again, just run `cargo wasi build` at project generates `.wasm` files with debug code properly inserted.
