== Drop won't be occur for values owned in separate threads when main panics

Context: phoseum doesn't terminates vlc process when panic occurs in main thread.

Here's tiny program to examine rust's behavior for drops.

[source, rust]
----
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

#[derive(Debug)]
struct Foo(&'static str);

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Drop {}", self.0);
    }
}

fn do_panic() {
    println!("panicing main thread");
    panic!("ahh");
}

fn main() {
    let _foo1 = Foo("foo");
    let foo_moved = Foo("foo_moved");
    let foo_shared = Arc::new(Foo("foo_shared"));
    let foo_shared_copy = Arc::clone(&foo_shared);

    let term = Arc::new(AtomicBool::new(false));
    let term_copy = Arc::clone(&term);
    let th = thread::spawn(move || {
        println!("foo_moved has moved to another thread: {:?}", foo_moved);
        println!(
            "foo_shared_copy has moved to another thread: {:?}",
            foo_shared_copy
        );
        while !term_copy.load(Ordering::Relaxed) {
            thread::sleep(Duration::from_secs(1));
        }
    });
    thread::sleep(Duration::from_secs(1));
    do_panic();
    term.store(true, Ordering::Relaxed);
    th.join().unwrap();
}
----

Result:
----
$ ./droptest
foo_moved has moved to another thread: Foo("foo_moved")
foo_shared_copy has moved to another thread: Foo("foo_shared")
panicing main thread
thread 'main' panicked at 'ahh', droptest.rs:17:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Drop foo
----


As https://doc.rust-lang.org/std/ops/trait.Drop.html#panics:[official doc] explains, drop occurs while stack unwinding and so is likely doesn't takes care of other thread's owned values (in different stack) before process termination.


== `match &str { "xxx" => ... }` vs `HashMap<&str, ...>`

Context: Wondering which is better performance wise to map from string to another value: match with string arms or prepared HashMap with string keys.

Did microbenchmark as it can be seen in link:./rust-bench/src/match_vs_map.rs[] .

Result:
----
test match_vs_map::bm_hashmap ... bench:         384 ns/iter (+/- 63)
test match_vs_map::bm_match   ... bench:          38 ns/iter (+/- 4)
----

Match is way faster than hashmap.

Edit: In order to make sure that there was no performance penalty caused by `lazy_static` which implements `Deref` for lazily evaluate initialization expression, I added another test that uses locally prebuilt `HashMap` instance. The result was as below confirming the difference is not due to `lazy_static`.

----
test match_vs_map::bm_hashmap_local  ... bench:         405 ns/iter (+/- 47)
test match_vs_map::bm_hashmap_static ... bench:         393 ns/iter (+/- 111)
test match_vs_map::bm_match          ... bench:          43 ns/iter (+/- 2)
----


== Allow trailing comma in macro repeat pattern

https://stackoverflow.com/questions/43143327/how-to-allow-optional-trailing-commas-in-macros

`$(,)?`


== `macro_rules` application order is determined by declaration order

Given below macro declarations:

[source,rust]
----
    ($lhs:expr, $op:ident, $rhs:expr ; $jump:ident) => {
    ...
    };
    ($($reg:ident),+ = $lhs:expr, $op:ident, $rhs:expr ; $jump:ident) => {
    ...
    };
----

with the usages below:

[source,rust]
----
i!(M,Plus,1;NOP);
or
i!(M=M,Plus,1;NOP);
----

the latter gets expanded with captures `$lhs:expr=(M=M)` by the 1st pattern, because while the intention is to match on 2nd with captures `$reg=(M) and $lhs=(M)`, the first can also match validly as "expression".

Flipping the order of two and putting more complex one on the top makes it behave as intended.

[source,rust]
----
    ($($reg:ident),+ = $lhs:expr, $op:ident, $rhs:expr ; $jump:ident) => {
    ...
    };
    ($lhs:expr, $op:ident, $rhs:expr ; $jump:ident) => {
    ...
    };
----
